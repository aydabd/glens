name: Bump Version and Create Annotated Tag
description: >
  Scans conventional commits for a module since its last semver tag, calculates
  the next version (major / minor / patch), creates an annotated git tag with a
  changelog, and pushes it. Designed to be called from a per-module release
  workflow inside the same repository or from an external repository via
  aydabd/glens/.github/actions/bump-and-tag@main.

inputs:
  tag-prefix:
    description: >
      Tag prefix that identifies this module's releases.
      Examples: "pkg/logging/v", "cmd/glens/v", "cmd/tools/demo/v".
    required: true
  module-path:
    description: >
      Relative path to the module root used to scope commit filtering.
      Examples: "pkg/logging", "cmd/glens", "cmd/tools/demo".
    required: true
  github-token:
    description: GitHub token with contents:write permission to push tags.
    required: true
  default-bump:
    description: >
      Fallback bump type when no conventional commit keywords are found.
      One of: patch | minor | major.
    required: false
    default: patch

outputs:
  tag:
    description: Full annotated tag that was created (e.g. "pkg/logging/v0.2.0").
    value: ${{ steps.compute.outputs.tag }}
  version:
    description: Semver string without prefix (e.g. "0.2.0").
    value: ${{ steps.compute.outputs.version }}
  previous-tag:
    description: The previous tag for this module (empty string on first release).
    value: ${{ steps.compute.outputs.previous_tag }}
  changelog:
    description: Markdown bullet list of commits since the previous tag.
    value: ${{ steps.compute.outputs.changelog }}

runs:
  using: composite
  steps:
    - name: Compute next version and changelog
      id: compute
      shell: bash
      env:
        TAG_PREFIX: ${{ inputs.tag-prefix }}
        MODULE_PATH: ${{ inputs.module-path }}
        DEFAULT_BUMP: ${{ inputs.default-bump }}
      run: |
        set -euo pipefail

        # ── Find last tag for this module ────────────────────────────────────
        LAST_TAG=$(git tag -l "${TAG_PREFIX}*" --sort=-version:refname | head -1 || true)
        echo "previous_tag=${LAST_TAG}" >> "$GITHUB_OUTPUT"

        # ── Collect commits since last tag scoped to module path ─────────────
        if [ -z "$LAST_TAG" ]; then
          COMMITS=$(git log --pretty=format:"%s" -- "${MODULE_PATH}" || true)
        else
          COMMITS=$(git log "${LAST_TAG}..HEAD" --pretty=format:"%s" -- "${MODULE_PATH}" || true)
        fi

        # ── Determine bump type from conventional commits ────────────────────
        # BREAKING CHANGE or feat!: → major; feat: → minor; else → default-bump
        BUMP="$DEFAULT_BUMP"
        if echo "$COMMITS" | grep -qEi "^(feat|feature)(\(.+\))?!:|BREAKING[- ]CHANGE"; then
          BUMP="major"
        elif echo "$COMMITS" | grep -qEi "^(feat|feature)(\(.+\))?:"; then
          BUMP="minor"
        fi

        # ── Parse last version ───────────────────────────────────────────────
        if [ -z "$LAST_TAG" ]; then
          LAST_VER="0.0.0"
        else
          LAST_VER="${LAST_TAG#"${TAG_PREFIX}"}"
        fi

        MAJOR=$(echo "$LAST_VER" | cut -d. -f1)
        MINOR=$(echo "$LAST_VER" | cut -d. -f2)
        PATCH=$(echo "$LAST_VER" | cut -d. -f3)

        # ── Apply bump ───────────────────────────────────────────────────────
        case "$BUMP" in
          major) MAJOR=$((MAJOR + 1)); MINOR=0; PATCH=0 ;;
          minor) MINOR=$((MINOR + 1)); PATCH=0 ;;
          patch) PATCH=$((PATCH + 1)) ;;
        esac

        NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
        NEW_TAG="${TAG_PREFIX}${NEW_VERSION}"

        echo "tag=${NEW_TAG}" >> "$GITHUB_OUTPUT"
        echo "version=${NEW_VERSION}" >> "$GITHUB_OUTPUT"
        echo "bump=${BUMP}" >> "$GITHUB_OUTPUT"

        # ── Build changelog ──────────────────────────────────────────────────
        if [ -z "$LAST_TAG" ]; then
          CHANGELOG=$(git log --pretty=format:"- %s (%h)" -- "${MODULE_PATH}" || true)
        else
          CHANGELOG=$(git log "${LAST_TAG}..HEAD" --pretty=format:"- %s (%h)" -- "${MODULE_PATH}" || true)
        fi

        if [ -z "$CHANGELOG" ]; then
          CHANGELOG="- No changes since previous release"
        fi

        # Multiline output via heredoc delimiter
        {
          echo "changelog<<GH_DELIM"
          echo "$CHANGELOG"
          echo "GH_DELIM"
        } >> "$GITHUB_OUTPUT"

    - name: Create and push annotated tag
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github-token }}
        NEW_TAG: ${{ steps.compute.outputs.tag }}
        CHANGELOG: ${{ steps.compute.outputs.changelog }}
        GITHUB_REPOSITORY: ${{ github.repository }}
      run: |
        set -euo pipefail

        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"

        # Authenticate push via token in remote URL
        git remote set-url origin \
          "https://x-access-token:${GITHUB_TOKEN}@github.com/${GITHUB_REPOSITORY}.git"

        printf 'Release %s\n\n%s\n' "${NEW_TAG}" "${CHANGELOG}" \
          | git tag -a "${NEW_TAG}" -F -
        git push origin "${NEW_TAG}"
